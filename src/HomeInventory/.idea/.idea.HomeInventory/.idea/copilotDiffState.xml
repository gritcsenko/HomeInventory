<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/../../README.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/../../README.md" />
              <option name="originalContent" value="# HomeInventory&#10;&#10;Inventory management for home&#10;&#10;## Statuses&#10;&#10;[![License](https://img.shields.io/badge/license-MIT-blue.svg)](https://github.com/gritcsenko/HomeInventory/blob/master/LICENSE)&#10;&#10;[![CI Build](https://github.com/gritcsenko/HomeInventory/actions/workflows/build.yml/badge.svg)](https://github.com/gritcsenko/HomeInventory/actions/workflows/build.yml)&#10;[![CodeQL](https://github.com/gritcsenko/HomeInventory/workflows/CodeQL/badge.svg)](https://github.com/gritcsenko/HomeInventory/actions?query=workflow%3ACodeQL)&#10;&#10;![.NET 10.0](https://img.shields.io/badge/Version-10.0-informational?logo=dotnet)&#10;![Built With Docker](https://img.shields.io/badge/Built_With-Docker-informational?logo=docker)&#10;[![Release strategy](https://img.shields.io/badge/Release%20strategy-GitHub_flow-informational.svg)](https://githubflow.github.io/)&#10;[![GitHub Release Date](https://img.shields.io/github/release-date/gritcsenko/HomeInventory?label=released)](https://github.com/gritcsenko/HomeInventory/releases)&#10;[![GitHub commits since latest release (by date)](https://img.shields.io/github/commits-since/gritcsenko/HomeInventory/latest?label=new+commits)](https://github.com/gritcsenko/HomeInventory/commits/main)&#10;![Size](https://img.shields.io/github/repo-size/gritcsenko/HomeInventory)&#10;&#10;[![GitHub repo stars](https://img.shields.io/github/stars/gritcsenko/HomeInventory)](https://github.com/gritcsenko/HomeInventory/stargazers)&#10;[![GitHub contributors](https://img.shields.io/github/contributors/gritcsenko/HomeInventory)](https://github.com/gritcsenko/HomeInventory/graphs/contributors)&#10;[![GitHub last commit](https://img.shields.io/github/last-commit/gritcsenko/HomeInventory)](https://github.com/gritcsenko/HomeInventory)&#10;![Activity](https://img.shields.io/github/commit-activity/w/gritcsenko/HomeInventory)&#10;![Activity](https://img.shields.io/github/commit-activity/m/gritcsenko/HomeInventory)&#10;![Activity](https://img.shields.io/github/commit-activity/y/gritcsenko/HomeInventory)&#10;[![GitHub open issues](https://img.shields.io/github/issues/gritcsenko/HomeInventory)](https://github.com/gritcsenko/HomeInventory/issues)&#10;[![Latest release](https://img.shields.io/github/release/gritcsenko/HomeInventory.svg?label=latest%20release&amp;color=007edf)](https://github.com/gritcsenko/HomeInventory/releases/latest)&#10;&#10;![Repobeats](https://repobeats.axiom.co/api/embed/a676f1d05c655d3151a703e5ecad09c8949dbdd6.svg &quot;Repobeats analytics image&quot;)&#10;&#10;Used code coverage report generator from [@danielpalme](https://github.com/danielpalme) / [ReportGenerator](https://github.com/danielpalme/ReportGenerator)&#10;&#10;## Give a Star! :star:&#10;[![Sparkline](https://stars.medv.io/gritcsenko/HomeInventory.svg)](https://stars.medv.io/gritcsenko/HomeInventory)&#10;&#10;If you like or are using this project please give it a star. Thanks!&#10;&#10;## Continuous Integration&#10;&#10;| Name            | Operating System      | Branch      | Status | History |&#10;| :---            | :---                  | :---   | :---   | :---    |&#10;| GitHub Actions  | Ubuntu                | [main](https://github.com/gritcsenko/HomeInventory/commits/main) | [![GitHub Actions Status](https://github.com/gritcsenko/HomeInventory/workflows/Build/badge.svg?branch=main)](https://github.com/gritcsenko/HomeInventory/actions) | [![GitHub Actions Build History](https://buildstats.info/github/chart/gritcsenko/HomeInventory?branch=main&amp;includeBuildsFromPullRequest=false)](https://github.com/gritcsenko/HomeInventory/actions) |&#10;&#10;# How do I build this?&#10;&#10;Install Visual Studio 2026 18.0+, Visual Studio Code, or JetBrains Rider. You will also need to have .NET 10.0 SDK installed. Check [global.json](src/HomeInventory/global.json) for the current minimum required version.&#10;&#10;## Contributions and Thanks&#10;&#10;For more information please view the [Contribution Guidelines](.github/CONTRIBUTING.md).&#10;" />
              <option name="updatedContent" value="# HomeInventory&#10;&#10;Inventory management for home&#10;&#10;## Statuses&#10;&#10;[![License](https://img.shields.io/badge/license-MIT-blue.svg)](https://github.com/gritcsenko/HomeInventory/blob/master/LICENSE)&#10;&#10;[![CI Build](https://github.com/gritcsenko/HomeInventory/actions/workflows/build.yml/badge.svg)](https://github.com/gritcsenko/HomeInventory/actions/workflows/build.yml)&#10;[![CodeQL](https://github.com/gritcsenko/HomeInventory/workflows/CodeQL/badge.svg)](https://github.com/gritcsenko/HomeInventory/actions?query=workflow%3ACodeQL)&#10;&#10;![.NET 10.0](https://img.shields.io/badge/Version-10.0-informational?logo=dotnet)&#10;![Built With Docker](https://img.shields.io/badge/Built_With-Docker-informational?logo=docker)&#10;[![Release strategy](https://img.shields.io/badge/Release%20strategy-GitHub_flow-informational.svg)](https://githubflow.github.io/)&#10;[![GitHub Release Date](https://img.shields.io/github/release-date/gritcsenko/HomeInventory?label=released)](https://github.com/gritcsenko/HomeInventory/releases)&#10;[![GitHub commits since latest release (by date)](https://img.shields.io/github/commits-since/gritcsenko/HomeInventory/latest?label=new+commits)](https://github.com/gritcsenko/HomeInventory/commits/main)&#10;![Size](https://img.shields.io/github/repo-size/gritcsenko/HomeInventory)&#10;&#10;[![GitHub repo stars](https://img.shields.io/github/stars/gritcsenko/HomeInventory)](https://github.com/gritcsenko/HomeInventory/stargazers)&#10;[![GitHub contributors](https://img.shields.io/github/contributors/gritcsenko/HomeInventory)](https://github.com/gritcsenko/HomeInventory/graphs/contributors)&#10;[![GitHub last commit](https://img.shields.io/github/last-commit/gritcsenko/HomeInventory)](https://github.com/gritcsenko/HomeInventory)&#10;![Activity](https://img.shields.io/github/commit-activity/w/gritcsenko/HomeInventory)&#10;![Activity](https://img.shields.io/github/commit-activity/m/gritcsenko/HomeInventory)&#10;![Activity](https://img.shields.io/github/commit-activity/y/gritcsenko/HomeInventory)&#10;[![GitHub open issues](https://img.shields.io/github/issues/gritcsenko/HomeInventory)](https://github.com/gritcsenko/HomeInventory/issues)&#10;[![Latest release](https://img.shields.io/github/release/gritcsenko/HomeInventory.svg?label=latest%20release&amp;color=007edf)](https://github.com/gritcsenko/HomeInventory/releases/latest)&#10;&#10;![Repobeats](https://repobeats.axiom.co/api/embed/a676f1d05c655d3151a703e5ecad09c8949dbdd6.svg &quot;Repobeats analytics image&quot;)&#10;&#10;Used code coverage report generator from [@danielpalme](https://github.com/danielpalme) / [ReportGenerator](https://github.com/danielpalme/ReportGenerator)&#10;&#10;## Give a Star! :star:&#10;[![Sparkline](https://stars.medv.io/gritcsenko/HomeInventory.svg)](https://stars.medv.io/gritcsenko/HomeInventory)&#10;&#10;If you like or are using this project please give it a star. Thanks!&#10;&#10;## Continuous Integration&#10;&#10;| Name            | Operating System      | Branch      | Status | History |&#10;| :---            | :---                  | :---   | :---   | :---    |&#10;| GitHub Actions  | Ubuntu                | [main](https://github.com/gritcsenko/HomeInventory/commits/main) | [![GitHub Actions Status](https://github.com/gritcsenko/HomeInventory/workflows/Build/badge.svg?branch=main)](https://github.com/gritcsenko/HomeInventory/actions) | [![GitHub Actions Build History](https://buildstats.info/github/chart/gritcsenko/HomeInventory?branch=main&amp;includeBuildsFromPullRequest=false)](https://github.com/gritcsenko/HomeInventory/actions) |&#10;&#10;# How do I build this?&#10;&#10;Install Visual Studio 2026 18.0+, Visual Studio Code, or JetBrains Rider. You will also need to have .NET 10.0 SDK installed. Check [global.json](src/HomeInventory/global.json) for the current minimum required version.&#10;&#10;## Contributions and Thanks&#10;&#10;For more information please view the [Contribution Guidelines](.github/CONTRIBUTING.md).&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/HomeInventory.Core/OptionExtensions.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/HomeInventory.Core/OptionExtensions.cs" />
              <option name="originalContent" value="namespace HomeInventory.Core;&#10;&#10;public static class OptionExtensions&#10;{&#10;    public static async Task&lt;Option&lt;T&gt;&gt; Tap&lt;T&gt;(this ValueTask&lt;Option&lt;T&gt;&gt; optionTask, Action&lt;T&gt; action) =&gt;&#10;        await optionTask.AsTask().Tap(action);&#10;&#10;    public static async Task&lt;Option&lt;T&gt;&gt; Tap&lt;T&gt;(this ValueTask&lt;Option&lt;T&gt;&gt; optionTask, Func&lt;T, Task&gt; asyncAction) =&gt;&#10;        await optionTask.AsTask().Tap(asyncAction);&#10;&#10;    public static async Task&lt;Option&lt;T&gt;&gt; Tap&lt;T&gt;(this ValueTask&lt;Option&lt;T&gt;&gt; optionTask, Func&lt;T, ValueTask&gt; asyncAction) =&gt;&#10;        await optionTask.AsTask().Tap(asyncAction);&#10;&#10;    public static async Task&lt;Option&lt;T&gt;&gt; Tap&lt;T&gt;(this Task&lt;Option&lt;T&gt;&gt; optionTask, Action&lt;T&gt; action) =&gt;&#10;        (await optionTask).Tap(action);&#10;&#10;    public static async Task&lt;Option&lt;T&gt;&gt; Tap&lt;T&gt;(this Task&lt;Option&lt;T&gt;&gt; optionTask, Func&lt;T, Task&gt; asyncAction) =&gt;&#10;        await (await optionTask).Tap(asyncAction);&#10;&#10;    public static async Task&lt;Option&lt;T&gt;&gt; Tap&lt;T&gt;(this Task&lt;Option&lt;T&gt;&gt; optionTask, Func&lt;T, ValueTask&gt; asyncAction) =&gt;&#10;        await (await optionTask).Tap(asyncAction);&#10;&#10;    public static Option&lt;T&gt; Tap&lt;T&gt;(this Option&lt;T&gt; option, Action&lt;T&gt; action)&#10;    {&#10;        if (option)&#10;        {&#10;            action((T)option);&#10;        }&#10;&#10;        return option;&#10;    }&#10;&#10;    public static async Task&lt;Option&lt;T&gt;&gt; Tap&lt;T&gt;(this Option&lt;T&gt; option, Func&lt;T, ValueTask&gt; asyncAction) =&gt;&#10;        await option.Tap(v =&gt; asyncAction(v).AsTask());&#10;&#10;    public static async Task&lt;Option&lt;T&gt;&gt; Tap&lt;T&gt;(this Option&lt;T&gt; option, Func&lt;T, Task&gt; asyncAction)&#10;    {&#10;        if (option)&#10;        {&#10;            await asyncAction((T)option);&#10;        }&#10;&#10;        return option;&#10;    }&#10;&#10;    public static async Task&lt;Option&lt;T&gt;&gt; IfAsync&lt;T&gt;(this Task&lt;Option&lt;T&gt;&gt; optionTask, Func&lt;T, CancellationToken, Task&lt;bool&gt;&gt; asyncCondition, CancellationToken cancellationToken = default)&#10;    {&#10;        var option = await optionTask;&#10;        return option.IsSome &amp;&amp; await asyncCondition((T)option, cancellationToken)&#10;            ? option&#10;            : Option&lt;T&gt;.None;&#10;    }&#10;&#10;    public static async Task&lt;TMatch&gt; MatchAsync&lt;T, TMatch&gt;(this Option&lt;T&gt; option, Func&lt;T, Task&lt;TMatch&gt;&gt; onValue, Func&lt;Task&lt;TMatch&gt;&gt; onNone) =&gt;&#10;        option.IsSome&#10;            ? await onValue((T)option)&#10;            : await onNone();&#10;&#10;    public static async Task&lt;TMatch&gt; MatchAsync&lt;T, TMatch&gt;(this Option&lt;T&gt; option, Func&lt;T, Task&lt;TMatch&gt;&gt; onValue, Func&lt;TMatch&gt; onNone) =&gt;&#10;        option.IsSome&#10;            ? await onValue((T)option)&#10;            : onNone();&#10;&#10;    public static async Task&lt;Option&lt;TMatch&gt;&gt; MatchAsync&lt;T, TMatch&gt;(this Option&lt;T&gt; option, Func&lt;T, Task&lt;TMatch&gt;&gt; onValue) =&gt;&#10;        option.IsSome&#10;            ? await onValue((T)option)&#10;            : Option&lt;TMatch&gt;.None;&#10;&#10;    public static async Task&lt;Option&lt;TResult&gt;&gt; ConvertAsync&lt;T, TResult&gt;(this Task&lt;Option&lt;T&gt;&gt; optionTask, Func&lt;T, CancellationToken, Task&lt;TResult&gt;&gt; asyncConverter, CancellationToken cancellationToken = default)&#10;    {&#10;        var option = await optionTask;&#10;        return await option.ConvertAsync(asyncConverter, cancellationToken);&#10;    }&#10;&#10;    public static async Task&lt;Option&lt;TResult&gt;&gt; ConvertAsync&lt;T, TResult&gt;(this Option&lt;T&gt; option, Func&lt;T, CancellationToken, Task&lt;TResult&gt;&gt; asyncConverter, CancellationToken cancellationToken = default) =&gt;&#10;        await option&#10;            .MatchAsync(async x =&gt; await asyncConverter(x, cancellationToken));&#10;&#10;    public static async Task&lt;Option&lt;TResult&gt;&gt; Convert&lt;T, TResult&gt;(this Task&lt;Option&lt;T&gt;&gt; optionTask, Func&lt;T, TResult&gt; converter)&#10;    {&#10;        var option = await optionTask;&#10;        return option.Select(converter);&#10;    }&#10;&#10;    public static Option&lt;T&gt; Coalesce&lt;T&gt;(this Option&lt;T&gt; first, Func&lt;Option&lt;T&gt;&gt; secondFunc) =&gt; first ? first : secondFunc();&#10;&#10;    public static Option&lt;T&gt; NoneIfNull&lt;T&gt;(this T? value) where T : class =&gt; value ?? Option&lt;T&gt;.None;&#10;&#10;    public static T ThrowIfNone&lt;T&gt;(this Option&lt;T&gt; option, Func&lt;Exception&gt; exceptionFactory) =&gt;&#10;        option.IfNone(() =&gt; exceptionFactory().Rethrow&lt;T&gt;());&#10;&#10;    public static Validation&lt;Error, T&gt; ErrorIfNone&lt;T&gt;(this Option&lt;Validation&lt;Error, T&gt;&gt; option, Func&lt;Error&gt; errorFactory) =&gt;&#10;        option.IfNone(() =&gt; errorFactory());&#10;&#10;    public static Validation&lt;Error, T&gt; ErrorIfNone&lt;T&gt;(this Option&lt;T&gt; option, Func&lt;Error&gt; errorsFactory) =&gt;&#10;        option&#10;            .Map(Validation.Success&lt;Error, T&gt;)&#10;            .IfNone(() =&gt; Validation.Fail&lt;Error, T&gt;(errorsFactory()));&#10;&#10;    public static Validation&lt;Error, T&gt; ErrorIfNone&lt;T&gt;(this Option&lt;T&gt; option, Error error) =&gt;&#10;        option.ErrorIfNone(() =&gt; error);&#10;}&#10;" />
              <option name="updatedContent" value="namespace HomeInventory.Core;&#10;&#10;public static class OptionExtensions&#10;{&#10;    public static async Task&lt;Option&lt;T&gt;&gt; Tap&lt;T&gt;(this ValueTask&lt;Option&lt;T&gt;&gt; optionTask, Action&lt;T&gt; action) =&gt;&#10;        await optionTask.AsTask().Tap(action);&#10;&#10;    public static async Task&lt;Option&lt;T&gt;&gt; Tap&lt;T&gt;(this ValueTask&lt;Option&lt;T&gt;&gt; optionTask, Func&lt;T, Task&gt; asyncAction) =&gt;&#10;        await optionTask.AsTask().Tap(asyncAction);&#10;&#10;    public static async Task&lt;Option&lt;T&gt;&gt; Tap&lt;T&gt;(this ValueTask&lt;Option&lt;T&gt;&gt; optionTask, Func&lt;T, ValueTask&gt; asyncAction) =&gt;&#10;        await optionTask.AsTask().Tap(asyncAction);&#10;&#10;    public static async Task&lt;Option&lt;T&gt;&gt; Tap&lt;T&gt;(this Task&lt;Option&lt;T&gt;&gt; optionTask, Action&lt;T&gt; action) =&gt;&#10;        (await optionTask).Tap(action);&#10;&#10;    public static async Task&lt;Option&lt;T&gt;&gt; Tap&lt;T&gt;(this Task&lt;Option&lt;T&gt;&gt; optionTask, Func&lt;T, Task&gt; asyncAction) =&gt;&#10;        await (await optionTask).Tap(asyncAction);&#10;&#10;    public static async Task&lt;Option&lt;T&gt;&gt; Tap&lt;T&gt;(this Task&lt;Option&lt;T&gt;&gt; optionTask, Func&lt;T, ValueTask&gt; asyncAction) =&gt;&#10;        await (await optionTask).Tap(asyncAction);&#10;&#10;    public static Option&lt;T&gt; Tap&lt;T&gt;(this Option&lt;T&gt; option, Action&lt;T&gt; action)&#10;    {&#10;        if (option)&#10;        {&#10;            action((T)option);&#10;        }&#10;&#10;        return option;&#10;    }&#10;&#10;    public static async Task&lt;Option&lt;T&gt;&gt; Tap&lt;T&gt;(this Option&lt;T&gt; option, Func&lt;T, ValueTask&gt; asyncAction) =&gt;&#10;        await option.Tap(v =&gt; asyncAction(v).AsTask());&#10;&#10;    public static async Task&lt;Option&lt;T&gt;&gt; Tap&lt;T&gt;(this Option&lt;T&gt; option, Func&lt;T, Task&gt; asyncAction)&#10;    {&#10;        if (option)&#10;        {&#10;            await asyncAction((T)option);&#10;        }&#10;&#10;        return option;&#10;    }&#10;&#10;    public static async Task&lt;Option&lt;T&gt;&gt; IfAsync&lt;T&gt;(this Task&lt;Option&lt;T&gt;&gt; optionTask, Func&lt;T, CancellationToken, Task&lt;bool&gt;&gt; asyncCondition, CancellationToken cancellationToken = default)&#10;    {&#10;        var option = await optionTask;&#10;        return option.IsSome &amp;&amp; await asyncCondition((T)option, cancellationToken)&#10;            ? option&#10;            : Option&lt;T&gt;.None;&#10;    }&#10;&#10;    public static async Task&lt;TMatch&gt; MatchAsync&lt;T, TMatch&gt;(this Option&lt;T&gt; option, Func&lt;T, Task&lt;TMatch&gt;&gt; onValue, Func&lt;Task&lt;TMatch&gt;&gt; onNone) =&gt;&#10;        option.IsSome&#10;            ? await onValue((T)option)&#10;            : await onNone();&#10;&#10;    public static async Task&lt;TMatch&gt; MatchAsync&lt;T, TMatch&gt;(this Option&lt;T&gt; option, Func&lt;T, Task&lt;TMatch&gt;&gt; onValue, Func&lt;TMatch&gt; onNone) =&gt;&#10;        option.IsSome&#10;            ? await onValue((T)option)&#10;            : onNone();&#10;&#10;    public static async Task&lt;Option&lt;TMatch&gt;&gt; MatchAsync&lt;T, TMatch&gt;(this Option&lt;T&gt; option, Func&lt;T, Task&lt;TMatch&gt;&gt; onValue) =&gt;&#10;        option.IsSome&#10;            ? await onValue((T)option)&#10;            : Option&lt;TMatch&gt;.None;&#10;&#10;    public static async Task&lt;Option&lt;TResult&gt;&gt; ConvertAsync&lt;T, TResult&gt;(this Task&lt;Option&lt;T&gt;&gt; optionTask, Func&lt;T, CancellationToken, Task&lt;TResult&gt;&gt; asyncConverter, CancellationToken cancellationToken = default)&#10;    {&#10;        var option = await optionTask;&#10;        return await option.ConvertAsync(asyncConverter, cancellationToken);&#10;    }&#10;&#10;    public static async Task&lt;Option&lt;TResult&gt;&gt; ConvertAsync&lt;T, TResult&gt;(this Option&lt;T&gt; option, Func&lt;T, CancellationToken, Task&lt;TResult&gt;&gt; asyncConverter, CancellationToken cancellationToken = default) =&gt;&#10;        await option&#10;            .MatchAsync(async x =&gt; await asyncConverter(x, cancellationToken));&#10;&#10;    public static async Task&lt;Option&lt;TResult&gt;&gt; Convert&lt;T, TResult&gt;(this Task&lt;Option&lt;T&gt;&gt; optionTask, Func&lt;T, TResult&gt; converter)&#10;    {&#10;        var option = await optionTask;&#10;        return option.Select(converter);&#10;    }&#10;&#10;    public static Option&lt;T&gt; Coalesce&lt;T&gt;(this Option&lt;T&gt; first, Func&lt;Option&lt;T&gt;&gt; secondFunc) =&gt; first ? first : secondFunc();&#10;&#10;    public static Option&lt;T&gt; NoneIfNull&lt;T&gt;(this T? value) where T : class =&gt; value ?? Option&lt;T&gt;.None;&#10;&#10;    public static T ThrowIfNone&lt;T&gt;(this Option&lt;T&gt; option, Func&lt;Exception&gt; exceptionFactory) =&gt;&#10;        option.IfNone(() =&gt; exceptionFactory().Rethrow&lt;T&gt;());&#10;&#10;    public static Validation&lt;Error, T&gt; ErrorIfNone&lt;T&gt;(this Option&lt;Validation&lt;Error, T&gt;&gt; option, Func&lt;Error&gt; errorFactory) =&gt;&#10;        option.IfNone(() =&gt; errorFactory());&#10;&#10;    public static Validation&lt;Error, T&gt; ErrorIfNone&lt;T&gt;(this Option&lt;T&gt; option, Func&lt;Error&gt; errorsFactory) =&gt;&#10;        option&#10;            .Map(Validation.Success&lt;Error, T&gt;)&#10;            .IfNone(() =&gt; Validation.Fail&lt;Error, T&gt;(errorsFactory()));&#10;&#10;    public static Validation&lt;Error, T&gt; ErrorIfNone&lt;T&gt;(this Option&lt;T&gt; option, Error error) =&gt;&#10;        option.ErrorIfNone(() =&gt; error);&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/HomeInventory.Tests.Framework/Assertions/LanguageExtOptionAssertions.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/HomeInventory.Tests.Framework/Assertions/LanguageExtOptionAssertions.cs" />
              <option name="originalContent" value="namespace HomeInventory.Tests.Framework.Assertions;&#10;&#10;public class LanguageExtOptionAssertions&lt;T&gt;(Option&lt;T&gt; instance, AssertionChain assertionChain) : ReferenceTypeAssertions&lt;Option&lt;T&gt;, LanguageExtOptionAssertions&lt;T&gt;&gt;(instance, assertionChain)&#10;{&#10;    protected override string Identifier =&gt; &quot;option&quot;;&#10;&#10;    public AndConstraint&lt;LanguageExtOptionAssertions&lt;T&gt;&gt; BeNone(string because = &quot;&quot;, params object[] becauseArgs)&#10;    {&#10;        CurrentAssertionChain&#10;            .BecauseOf(because, becauseArgs)&#10;            .WithExpectation(&quot;Expected {context:option} to be None{reason}, &quot;, c =&gt; c&#10;                .Given(() =&gt; Subject)&#10;                .ForCondition(subject =&gt; subject.IsNone)&#10;                .FailWith(&quot;but found to be Some.&quot;));&#10;&#10;        return new(this);&#10;    }&#10;&#10;    public AndWhichConstraint&lt;LanguageExtOptionAssertions&lt;T&gt;, T&gt; BeSome(string because = &quot;&quot;, params object[] becauseArgs)&#10;    {&#10;        CurrentAssertionChain&#10;            .BecauseOf(because, becauseArgs)&#10;            .WithExpectation(&quot;Expected {context:option} to be Some{reason}, &quot;, c =&gt; c&#10;                .Given(() =&gt; Subject)&#10;                .ForCondition(subject =&gt; subject.IsSome)&#10;                .FailWith(&quot;but found to be None.&quot;));&#10;&#10;        var value = Subject.Match(Some: v =&gt; v, None: () =&gt; default!);&#10;        return new(this, value);&#10;    }&#10;&#10;    public AndConstraint&lt;LanguageExtOptionAssertions&lt;T&gt;&gt; BeSome(Action&lt;T&gt; action, string because = &quot;&quot;, params object[] becauseArgs)&#10;    {&#10;        BeSome(because, becauseArgs);&#10;        Subject.IfSome(action);&#10;&#10;        return new(this);&#10;    }&#10;&#10;    public AndConstraint&lt;LanguageExtOptionAssertions&lt;T&gt;&gt; Be(T expected, string because = &quot;&quot;, params object[] becauseArgs)&#10;    {&#10;        CurrentAssertionChain&#10;            .BecauseOf(because, becauseArgs)&#10;            .WithExpectation(&quot;Expected {context:option} to be Some {0}{reason}, &quot;, expected, c =&gt; c&#10;                .Given(() =&gt; Subject)&#10;                .ForCondition(subject =&gt; subject.IsSome)&#10;                .FailWith(&quot;but found to be None.&quot;)&#10;                .Then&#10;                .ForCondition(subject =&gt; subject.Equals(expected))&#10;                .FailWith(&quot;but found Some {0}.&quot;, Subject));&#10;&#10;        return new(this);&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="namespace HomeInventory.Tests.Framework.Assertions;&#13;&#10;&#13;&#10;public class LanguageExtOptionAssertions&lt;T&gt;(Option&lt;T&gt; instance, AssertionChain assertionChain) : ReferenceTypeAssertions&lt;Option&lt;T&gt;, LanguageExtOptionAssertions&lt;T&gt;&gt;(instance, assertionChain)&#13;&#10;{&#13;&#10;    protected override string Identifier =&gt; &quot;option&quot;;&#13;&#10;&#13;&#10;    public AndConstraint&lt;LanguageExtOptionAssertions&lt;T&gt;&gt; BeNone(string because = &quot;&quot;, params object[] becauseArgs)&#13;&#10;    {&#13;&#10;        CurrentAssertionChain&#13;&#10;            .BecauseOf(because, becauseArgs)&#13;&#10;            .WithExpectation(&quot;Expected {context:option} to be None{reason}, &quot;, c =&gt; c&#13;&#10;                .Given(() =&gt; Subject)&#13;&#10;                .ForCondition(subject =&gt; subject.IsNone)&#13;&#10;                .FailWith(&quot;but found to be Some.&quot;));&#13;&#10;&#13;&#10;        return new(this);&#13;&#10;    }&#13;&#10;&#13;&#10;    public AndWhichConstraint&lt;LanguageExtOptionAssertions&lt;T&gt;, T&gt; BeSome(string because = &quot;&quot;, params object[] becauseArgs)&#10;    {&#10;        CurrentAssertionChain&#10;            .BecauseOf(because, becauseArgs)&#10;            .WithExpectation(&quot;Expected {context:option} to be Some{reason}, &quot;, c =&gt; c&#10;                .Given(() =&gt; Subject)&#10;                .ForCondition(subject =&gt; subject.IsSome)&#10;                .FailWith(&quot;but found to be None.&quot;));&#10;&#10;        var value = Subject.Match(Some: v =&gt; v, None: () =&gt; default!);&#10;        return new(this, value);&#10;    }&#13;&#10;&#13;&#10;    public AndConstraint&lt;LanguageExtOptionAssertions&lt;T&gt;&gt; BeSome(Action&lt;T&gt; action, string because = &quot;&quot;, params object[] becauseArgs)&#13;&#10;    {&#13;&#10;        BeSome(because, becauseArgs);&#13;&#10;        Subject.IfSome(action);&#13;&#10;&#13;&#10;        return new(this);&#13;&#10;    }&#13;&#10;&#13;&#10;    public AndConstraint&lt;LanguageExtOptionAssertions&lt;T&gt;&gt; Be(T expected, string because = &quot;&quot;, params object[] becauseArgs)&#13;&#10;    {&#13;&#10;        CurrentAssertionChain&#13;&#10;            .BecauseOf(because, becauseArgs)&#13;&#10;            .WithExpectation(&quot;Expected {context:option} to be Some {0}{reason}, &quot;, expected, c =&gt; c&#13;&#10;                .Given(() =&gt; Subject)&#13;&#10;                .ForCondition(subject =&gt; subject.IsSome)&#13;&#10;                .FailWith(&quot;but found to be None.&quot;)&#13;&#10;                .Then&#13;&#10;                .ForCondition(subject =&gt; subject.Equals(expected))&#13;&#10;                .FailWith(&quot;but found Some {0}.&quot;, Subject));&#13;&#10;&#13;&#10;        return new(this);&#13;&#10;    }&#13;&#10;}&#13;&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>